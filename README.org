#+TITLE: Cool Emacs config.
#+AUTHOR: Scriptod
#+STARTUP: overview

* Package Management
** Package archives
Repositories of Emacs-lisp packages.

#+BEGIN_SRC emacs-lisp
(defvar gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")

(require 'package)

(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")))
#+END_SRC
** Straight
A purely functional package manager for an Emacs hacker.

#+BEGIN_SRC emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+END_SRC
** Use-package
Bootstrapping use-package - A cool macro that can both speed-up and make tidier your config. 

#+BEGIN_SRC emacs-lisp
(straight-use-package 'use-package)
#+END_SRC
** Quelpa
For installing packages from sources.

#+BEGIN_SRC emacs-lisp
(use-package quelpa
  :straight t)
#+END_SRC
** Try
Try is a tool for trying packages in Emacs without installing them permanently.

#+BEGIN_SRC emacs-lisp
(use-package try
  :straight t)
#+END_SRC

* Startup
** Start the server
If you don't use Emacs in a server mode then you definitely doing something wrong.

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC
* Libraries
** Dash
A modern list library for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package dash
  :straight t)
#+END_SRC

** Seq
Sequence-manipulation functions that complement basic functions.

#+BEGIN_SRC emacs-lisp
(use-package seq
  :ensure nil)
#+END_SRC

** Prescient
/*"Simple but effective sorting and filtering for Emacs."*/

#+BEGIN_SRC emacs-lisp
(use-package prescient
  :straight t
  :custom
  (prescient-filter-method '(literal regexp initialism fuzzy))
  :config
  (prescient-persist-mode t))
#+END_SRC

Here's an interface for it to work with company.

#+BEGIN_SRC emacs-lisp
(use-package company-prescient
  :straight t
  :after company
  :config
  (company-prescient-mode t))
#+END_SRC

...and with Selectrum

#+BEGIN_SRC emacs-lisp
;(use-package selectrum-prescient
;  :straight t
;  :after selectrum
;  :config
;  (selectrum-prescient-mode t))
#+END_SRC

...and with ivy

#+BEGIN_SRC emacs-lisp
(use-package ivy-prescient
  :straight t
  :after ivy
  :config
  (ivy-prescient-mode t))
#+END_SRC
** Cl-lib
Common-lisp extensions for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package cl-lib
  :ensure nil)
#+END_SRC
* Interface & Appearence
** C source code variables
#+BEGIN_SRC emacs-lisp 
(use-package emacs
  :ensure nil
  :init
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  :custom
  (use-dialog-box nil "Dialogs via minibuffer only.")
  (tool-bar-mode nil "Disable toolbar.")
  (menu-bar-mode nil "Disable menubar.")
  (scroll-bar-mode nil "Disable scrollbar.")
  (blink-cursor-mode nil "Disable cursor blinking.")
  (scroll-step 1 "Scroll line by line.")
  (scroll-margin 4 "Top and bottom scrolling margin.")
  (inhibit-splash-screen t "Don't show the splash screen.")
  (indicate-empty-lines t "Visually indicate empty lines.")
  (indent-tabs-mode nil "Tabs are evil.")
  (tab-width 4 "Sane default for me."))
#+END_SRC
** Simple
#+BEGIN_SRC emacs-lisp
(use-package simple
  :ensure nil
  :config
  (defalias 'yes-or-no-p 'y-or-n-p)
  :custom
  (line-number-mode t "Show line number in modeline.")
  (column-number-mode t "Show column number in modeline."))
#+END_SRC
** Themes
#+BEGIN_SRC emacs-lisp
;(use-package doom-themes
;  :ensure t
;  :config
;  (load-theme 'doom-wilmersdorf t)
;  (set-face-attribute 'mode-line nil
;            :background "#282b33")
;  (set-face-attribute 'mode-line-inactive nil
;            :background "#282b33"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
 :straight t
 :custom-face
 (org-document-title ((t :height 170)))
 :config
 (load-theme 'doom-Iosvkem t))
#+END_SRC
** Fonts & Faces
#+BEGIN_SRC emacs-lisp
(use-package faces
  :ensure nil
  :config
  (set-face-attribute 'default
                      nil
                      :family "Hack"
                      :weight 'semi-light
                      :width 'semi-condensed
                      :height 130))
#+END_SRC
** Modeline
Mood-line is the most minimalistic modeline for Emacs I've ever seen.

#+BEGIN_SRC emacs-lisp
(use-package mood-line
  :straight t
  :config
  (mood-line-mode)
  :custom-face
  (mode-line ((t :background "#1b1d1e" :overline t)))
  (mode-line-inactive ((nil :background "#1b1d1e" :overline t)))
  :custom 
  (overline-margin '15)
  (underline-margin '10))
#+END_SRC
** Icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :if window-system
  :straight t
  :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :if window-system
  :straight t
  :hook
  (dired-mode . all-the-icons-dired-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-ivy
  :if window-system
  :straight t
  :after ivy
  :custom
  (all-the-icons-ivy-buffer-commands '() "Don't use for buffers.")
  :config
  (unless (file-exists-p "~/.local/share/fonts/all-the-icons.ttf")
    (all-the-icons-install-fonts t)
    (all-the-icons-ivy-setup)))
#+END_SRC
** Beacon
"Here your cursor is"

#+BEGIN_SRC emacs-lisp
(use-package beacon
  :straight t
  :config
  (beacon-mode t))
#+END_SRC
** Dashboard
A cool dashboard to see every time I load muh Emacs.

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :straight t
  :config
  (dashboard-setup-startup-hook)
  ;; Set the title
  (setq dashboard-banner-logo-title "Happy Hacking.")
  ;; Set the banner
  (setq dashboard-startup-banner 'logo))
#+END_SRC
** Darkroom
Distraction-free mode.

#+BEGIN_SRC emacs-lisp
(use-package darkroom
  :straight t)
#+END_SRC
* Keyboard & Shortcuts
** General
General.el is a cool interface for making key bindings.

#+BEGIN_SRC emacs-lisp
(use-package general
  :straight t)
#+END_SRC
** Hydra
/* "Make bindings that stick around" */

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :straight t)
#+END_SRC

Hydra integration with use-package.

#+BEGIN_SRC emacs-lisp
(use-package use-package-hydra
  :straight t)
#+END_SRC
** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :straight t)
#+END_SRC
** Modal editing
Modal editing is more efficient and ergonomical way to edit text.
The package I use for implementing modal editing to my config is called Modalka.
*** Editing Hydras
**** Killing
#+BEGIN_SRC emacs-lisp
(defhydra hydra-kill (:color red)
    "kill"
    ("j" delete-backward-char "backward-char")
    ("l" delete-char "char")
    ("u" backward-kill-word "backward-word")
    ("o" kill-word "word")
    ("v" kill-region "region" :color blue)
    ("d" kill-whole-line "line")
    (";" kill-line "end-of-line")
    ("h" reverse-kill-line "to-beginnig-of-line")
    ("t" zap-to-char "to-char" :color blue)
    ("g" nil "quit"))
#+END_SRC

**** Yanking
#+BEGIN_SRC emacs-lisp
(defhydra hydra-yank ()
  "yank"
  ("y" yank nil)
  ("t" yank-pop nil)
  ("k" (yank-pop 1) "next")
  ("i" (yank-pop -1) "prev")
  ("l" counsel-yank-pop "list" :color blue)
  ("g" nil "quit"))
#+END_SRC
**** Goto line
#+BEGIN_SRC emacs-lisp
(defhydra hydra-goto-line (goto-map ""
                           :pre (linum-mode 1)
                           :post (linum-mode -1))
  "goto-line"
  ("z" goto-line "go")
  ("v" set-mark-command "mark" :bind nil)
  ("g" nil "quit"))
#+END_SRC
**** Move text
#+BEGIN_SRC emacs-lisp
(defhydra hydra-move-text ()
  "Move text"
  ("u" move-text-up "up")
  ("d" move-text-down "down")
  ("g" nil "quit"))
#+END_SRC
**** Capitalizing
#+BEGIN_SRC emacs-lisp
(defhydra hydra-capitalize ()
  "capitalize"
  ("o" capitalize-word "word")
  ("v" capitalize-region "region"))
#+END_SRC
**** Evaluation
#+BEGIN_SRC emacs-lisp
(defhydra hydra-eval (:color blue)
    "eval"
    ("d" eval-defun "defun")
    ("b" eval-buffer "buffer")
    ("r" eval-region "region")
    ("s" eval-last-sexp "last-sexp")
    ("e" eval-expression "expression")
    ("g" nil "quit"))
#+END_SRC
**** Help
#+BEGIN_SRC emacs-lisp
(defhydra hydra-help (:color blue)
    ("m" man "man")
    ("i" info "info")
    ("?" help-for-help "help-for-help")
    ("n" view-emacs-news "news")
    ("C" describe-coding-system "describe-coding-system")
    ("I" describe-input-method "describe-input-method")
    ("L" describe-language-environment "describe-language-environment")
    ("P" describe-package "describe-package")
    ("b" describe-bindings "describe-bindings")
    ("c" describe-key-briefly "describe-key-briefly")
    ("f" describe-function "describe-function")
    ("g" describe-gnu-project "describe-gnu-project")
    ("k" describe-key "describe-key")
    ("m" describe-mode "describe-mode")
    ("o" describe-symbol "describe-symbol")
    ("v" describe-variable "describe-variable")
    ("g" nil "quit"))
#+END_SRC
**** Package Management
#+BEGIN_SRC emacs-lisp
(defhydra hydra-package (:color blue)
    ("i" package-install "install")
    ("r" package-refresh-contents "refresh-contents" :color red)
    ("t" try "try")
    ("d" package-delete "delete")
    ("l" package-list-packages "list-packages")
    ("g" nil "quit"))
#+END_SRC
**** Buffer navigation & manipulation
#+BEGIN_SRC emacs-lisp
(defhydra hydra-buffer (:color blue)
    ("k" kill-buffer "kill-buffer")
    ("K" kill-buffer-and-window "kill-buffer-and-window")
    ("m" buffer-menu "buffer-menu")
    ("j" previous-buffer "previous-buffer" :color red)
    ("l" next-buffer "next-buffer" :color red)
    ("s" switch-to-buffer "switch-buffer")
    ("g" nil "quit"))
#+END_SRC
**** Zooming
Zooming in and out. One of the space commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-zoom ()
    "zoom"
    ("i" text-scale-increase "in")
    ("k" text-scale-decrease "out"))
#+END_SRC
**** Mark ring
#+BEGIN_SRC emacs-lisp
(use-package back-button
  :straight t
  :after modalka
  :hydra (hydra-mark-ring ()
  ("v" set-mark-command "set-mark")
  ("j" back-button-local-forward "local-forward")
  ("l" back-button-local-backward "local-backward")
  ("g" nil "quit")))
#+END_SRC
**** Space-commands
Commands that you don't need right at your fingers, but ones you need pretty often. Bound to Space.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-space-commands (:color blue)
    ("s" save-buffer "save-buffer" :color red)
    ("f" find-file "find-file")
    ("Q" kill-emacs "kill-emacs")
    ("d" dired "dired")
    ("a" org-agenda "org-agenda")
    ("p" hydra-package/body "package")
    ("z" hydra-zoom/body "zoom")
    ("h" hydra-help/body "help")
    ("i" beginning-of-buffer "beginning")
    ("k" end-of-buffer "end-of-buffer")
    ("u" scroll-down "scroll-up")
    ("o" scroll-up "scroll-down")
    ("e" hydra-eval/body "eval")
    ("r" replace-string "replace-string")
    ("g" nil "quit"))
#+END_SRC
*** Modalka
#+BEGIN_SRC emacs-lisp
;; These functions will be needed soon.
(defun enable-modalka-mode ()
 (interactive)
 (modalka-mode t))

(defun reverse-kill-line ()
  (interactive)
  (kill-line 0))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package modalka
  :straight t
  :after avy
  :general
  ("C-;" 'enable-modalka-mode)
  ("<escape>" 'enable-modalka-mode) ; enable insert-mode
  ('modalka-mode-map
  "p" 'modalka-mode ; enable insert-mode
;; Navigation
  "j" 'backward-char
  "l" 'forward-char
  "k" 'next-line
  "i" 'previous-line
  "u" 'left-word
  "o" 'right-word
  "f" 'avy-goto-word-0
  "h" 'beginning-of-line
  ";" 'end-of-line
  "z" 'hydra-goto-line
  "m" 'hydra-move-text/body
;; Editing
  "v" 'hydra-mark-ring/body
  "y" 'undo
  "c" 'hydra-copy/body
  "a" 'execute-extended-command
  "n" 'universal-argument
  "g" 'keyboard-quit
  "d" 'hydra-kill/body
  "c" 'copy-region-as-kill
  "s" 'isearch-forward
  "r" 'hydra-capitalize/body
  "t" 'hydra-yank/yank
  "(" 'backward-sexp
  ")" 'forward-sexp
;; Everything else
  "x" 'hydra-buffer/body
  "SPC" 'hydra-space-commands/body)
  :custom
  (cursor-type '(bar . 1))
  (modalka-cursor-type 'box)
  :hook
  (after-init . modalka-global-mode))
#+END_SRC
** Autocompletion
*** Minibuffer completion
**** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :straight t
  :config
  (ivy-mode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :after counsel
  :straight t
  :config
  (ivy-rich-mode t))
#+END_SRC
**** Counsel
Amx is used by ~Counsel-M-x~.

#+BEGIN_SRC emacs-lisp
(use-package amx 
  :straight t 
  :defer t)
#+END_SRC

Counsel itself.

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :straight t
  :bind
  (([remap insert-char] . counsel-unicode-char)
   ([remap isearch-forward] . counsel-grep-or-swiper))
  :init
  (counsel-mode))
#+END_SRC

**** Swiper
#+BEGIN_SRC emacs-lisp
(use-package swiper 
  :straight t)
#+END_SRC

**** Selectrum
#+BEGIN_SRC emacs-lisp
;(use-package selectrum
;  :straight t
;  :config 
;  (selectrum-mode t))
#+END_SRC
*** In-buffer completion
**** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :straight t
  :hook
  (after-init . global-company-mode))
#+END_SRC
**** Electric pairs
#+BEGIN_SRC emacs-lisp
(use-package elec-pair
  :config
  (electric-pair-mode t))
#+END_SRC
** Frame Manipulation
#+BEGIN_SRC emacs-lisp
(use-package frame
  :ensure nil
  :after modalka
  :hydra (hydra-frame-movement ()
  ("o" other-frame "other-frame")
  ("3" make-frame-command "make-frame-command")
  ("2" delete-other-frames "delete-other-frames")
  ("1" delete-frame "delete-frame"))
  :general
  ;; Disable suspending
  ("C-z" . nil)
  ("C-z C-z" . nil)
  (:keymaps 'modalka-mode-map
  "e" 'hydra-frame-movement/body))
#+END_SRC
** Window manipulation
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :straight t
  :after modalka
  :hydra (hydra-windmove ()
  ("j" windmove-left "left")
  ("i" windmove-up "up")
  ("k" windmove-down "down")
  ("l" windmove-right "right")
  ("3" split-window-right "split-window-right")
  ("2" delete-other-windows "delete-other-windows")
  ("1" delete-window "delete-window")
  ("g" nil "quit"))
  :general 
  (:keymaps 'modalka-mode-map
  "w" 'hydra-windmove/body))
#+END_SRC
* Help & Manuals
** Helpful
Helpful provides better Emacs "help" buffer

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :straight t)
#+END_SRC
** Which key?
A nice little tool to remind you about what keys do you want to press.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :straight t
  :config
  (which-key-mode t))
#+END_SRC
* Term & Shell
** Vterm
#+BEGIN_SRC emacs-lisp
;(use-package vterm
;  :straight t)
#+END_SRC
* Org & Documents
** Org
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil)
#+END_SRC
** PDF-tools

For viewing Pointless-Document-Format docs in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :straight t)
#+END_SRC 
* File management
** Dired
Dired is a built-in Emacs file manager.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil)
#+END_SRC

Extra dired things

#+BEGIN_SRC emacs-lisp
(use-package dired-x
  :ensure nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :straight t
  :after dired
  :bind
  (:map dired-mode-map
        ("t" . dired-subtree-toggle)))
#+END_SRC

Image preview support for dired.

#+BEGIN_SRC emacs-lisp
(use-package image-dired
  :ensure nil)

(use-package image-dired+
  :straight t
  :after image-dired)
#+END_SRC

Hide dotfiles in dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package dired-hide-dotfiles
  :straight t
  :bind
  (:map dired-mode-map
        ("." . dired-hide-dotfiles-mode))
  :hook
  (dired-mode . dired-hide-dotfiles-mode))
#+END_SRC


Asynchronous dired

#+BEGIN_SRC emacs-lisp
(use-package async
  :straight t
  :defer t
  :init
  (dired-async-mode t))
#+END_SRC
** Set a backup directory
#+BEGIN_SRC emacs-lisp
(use-package files
  :ensure nil
  :custom
  (require-final-newline t)
  (delete-old-versions t)
  (backup-directory-alist
   `((".*" . ,(expand-file-name (concat user-emacs-directory "autosaves/")))))
  (auto-save-file-name-transforms
   `((".*" ,(expand-file-name (concat user-emacs-directory "autosaves/")) t))))
#+END_SRC
* Custom
I don't use ~M-x customize~ insterface, so custom-file is set to /dev/null.

#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :ensure nil
  :custom
  (custom-file "/dev/null"))
#+END_SRC


