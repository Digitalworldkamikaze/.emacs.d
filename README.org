#+TITLE: Cool Emacs config.
#+AUTHOR: Scriptod
#+STARTUP: overview

* Package Management
** Package archives
Repositories of Emacs-lisp packages.

#+BEGIN_SRC emacs-lisp
(defvar gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")

(require 'package)

(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")))
#+END_SRC
** Straight
A purely functional package manager for an Emacs hacker.

#+BEGIN_SRC emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+END_SRC
** Use-package
Bootstrapping use-package - A cool macro that can both speed-up and make tidier your config. 

#+BEGIN_SRC emacs-lisp
(straight-use-package 'use-package)
#+END_SRC
** Quelpa
For installing packages from sources.

#+BEGIN_SRC emacs-lisp
(use-package quelpa
  :straight t)
#+END_SRC
** Try
Try is a tool for trying packages in Emacs without installing them permanently.

#+BEGIN_SRC emacs-lisp
(use-package try
  :straight t)
#+END_SRC

* Startup
** Start the server
If you don't use Emacs in a server mode then you definitely doing something wrong.

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC
* Interface & Appearence
** C source code variables
#+BEGIN_SRC emacs-lisp 
(use-package emacs
  :ensure nil
  :init
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  :custom
  (use-dialog-box nil "Dialogs via minibuffer only.")
  (tool-bar-mode nil "Disable toolbar.")
  (menu-bar-mode nil "Disable menubar.")
  (scroll-bar-mode nil "Disable scrollbar.")
  (blink-cursor-mode nil "Disable cursor blinking.")
  (scroll-step 1 "Scroll line by line.")
  (scroll-margin 4 "Top and bottom scrolling margin.")
  (inhibit-splash-screen t "Don't show the splash screen.")
  (indicate-empty-lines t "Visually indicate empty lines.")
  (indent-tabs-mode nil "Tabs are evil.")
  (tab-width 4 "Sane default for me."))
#+END_SRC
** Simple
#+BEGIN_SRC emacs-lisp
(use-package simple
  :ensure nil
  :config
  (defalias 'yes-or-no-p 'y-or-n-p)
  :custom
  (line-number-mode t "Show line number in modeline.")
  (column-number-mode t "Show column number in modeline."))
#+END_SRC
** Themes
#+BEGIN_SRC emacs-lisp
;(use-package doom-themes
;  :ensure t
;  :config
;  (load-theme 'doom-wilmersdorf t)
;  (set-face-attribute 'mode-line nil
;            :background "#282b33")
;  (set-face-attribute 'mode-line-inactive nil
;            :background "#282b33"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
 :straight t
 :custom-face
 (org-document-title ((t :height 170)))
 (org-level-1 ((t :height 155 :foreground "#6c9ef8")))
 (org-level-2 ((t :height 135 :foreground "#a9a1e1")))
 (org-level-3 ((t :height 115 :foreground "#00aa80")))
 :config
 (load-theme 'doom-Iosvkem t))
#+END_SRC
** Modeline
Mood-line is the most minimalistic modeline for Emacs I've ever seen.

#+BEGIN_SRC emacs-lisp
(use-package mood-line
  :straight t
  :config
  (mood-line-mode)
  :custom-face
  (mode-line ((t :background "#1b1d1e" :overline t)))
  (mode-line-inactive ((nil :background "#1b1d1e" :overline t)))
  :custom 
  (overline-margin '15)
  (underline-margin '10))
#+END_SRC
** Icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :if window-system
  :straight t
  :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :if window-system
  :straight t
  :hook
  (dired-mode . all-the-icons-dired-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-ivy
  :if window-system
  :straight t
  :after ivy
  :custom
  (all-the-icons-ivy-buffer-commands '() "Don't use for buffers.")
  :config
  (unless (file-exists-p "~/.local/share/fonts/all-the-icons.ttf")
    (all-the-icons-install-fonts t)
    (all-the-icons-ivy-setup)))
#+END_SRC
** Dashboard
A cool dashboard to see every time I load muh Emacs.

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :straight t
  :config
  (dashboard-setup-startup-hook)
  ;; Set the title
  (setq dashboard-banner-logo-title "Happy Hacking.")
  ;; Set the banner
  (setq dashboard-startup-banner 'logo))
#+END_SRC
* Keyboard & Shortcuts
** Which key?
A nice little tool to remind you about what keys do you want to press.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :straight t
  :config
  (which-key-mode t))
#+END_SRC
** General
General.el is a cool interface for making key bindings.

#+BEGIN_SRC emacs-lisp
(use-package general
  :straight t)
#+END_SRC
** Hydra
"Make bindings that stick around"

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :straight t)
#+END_SRC

Hydra integration with use-package.

#+BEGIN_SRC emacs-lisp
(use-package use-package-hydra
  :straight t)
#+END_SRC
** Mark ring navigation
#+BEGIN_SRC emacs-lisp
(use-package back-button
  :straight t
  :after modalka
  :hydra (hydra-mark-ring ()
  ("j" back-button-local-forward "local-forward")
  ("l" back-button-local-backward "local-backward")
  ("g" nil "quit"))
  :general
  (:keymaps 'modalka-mode-map
  "t" 'hydra-mark-ring/body))
#+END_SRC
** Modal editing
Modal editing is more efficient and ergonomical way to edit text. The package I use for implementing modal editing to my config is called Modalka.

#+BEGIN_SRC emacs-lisp
;; These functions will be needed soon.
(defun enable-modalka-mode ()
 (interactive)
 (modalka-mode t))

(defun reverse-kill-line ()
  (interactive)
  (kill-line 0))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package modalka
  :straight t
  :hydra (hydra-kill ()
    ("j" delete-backward-char "backward-char")
    ("l" delete-char "char")
    ("u" backward-kill-word "backward-word")
    ("o" kill-word "word")
    ("v" kill-region "region" :color blue)
    ("d" kill-whole-line "line")
    (";" kill-line "end-of-line")
    ("h" reverse-kill-line "beginnig-of-line")
    ("g" nil "quit"))
  :hydra (hydra-eval (:color blue)
    ("d" eval-defun "defun")
    ("b" eval-buffer "buffer")
    ("r" eval-region "region")
    ("s" eval-last-sexp "last-sexp")
    ("e" eval-expression "expression")
    ("g" nil "quit"))
  :hydra (hydra-help (:color blue)
    ("m" man "man")
    ("n" view-emacs-news "news")
    ("d k" describe-key "describe-key")
    ("d f" describe-function "describe-function")
    ("d v" describe-variable "describe-variable")
    ("g" nil "quit"))
  :hydra (hydra-package (:color blue)
    ("i" package-install "install")
    ("r" package-refresh-contents "refresh-contents" :color red)
    ("t" try "try")
    ("d" package-delete "delete")
    ("l" package-list-packages "list-packages")
    ("g" nil "quit"))
  :hydra (hydra-buffer (:color blue)
    ("k" kill-buffer "kill-buffer")
    ("K" kill-buffer-and-window "kill-buffer-and-window")
    ("m" buffer-menu "buffer-menu")
    ("j" previous-buffer "previous-buffer" :color red)
    ("l" next-buffer "next-buffer" :color red)
    ("s" switch-to-buffer "switch-buffer")
    ("g" nil "quit"))
  :hydra (hydra-space-commands (:color blue)
    ("s" save-buffer "save-buffer" :color red)
    ("f" find-file "find-file")
    ("Q" kill-emacs "kill-emacs")
    ("d" dired "dired")
    ("a" org-agenda "org-agenda")
    ("p" hydra-package/body "package")
    ("z" hydra-zoom/body "zoom")
    ("g" nil "quit"))
  :hydra (hydra-zoom ()
    "zoom"
    ("i" text-scale-increase "in")
    ("k" text-scale-decrease "out"))
  :general 
  ("<escape>" 'enable-modalka-mode)
  ('modalka-mode-map
  "p" 'modalka-mode
  "j" 'backward-char
  "u" 'left-word
  "C-u" 'scroll-up
  "k" 'next-line
  "C-k" 'end-of-buffer
  "i" 'previous-line
  "C-i" 'beginning-of-buffer
  "l" 'forward-char
  "o" 'right-word
  "C-o" 'scroll-down
  "h" 'beginning-of-line
  ";" 'end-of-line
  "y" 'undo
  "v" 'set-mark-command
  "c" 'copy-region-as-kill
  "a" 'execute-extended-command
  "s" 'isearch-forward
  "n" 'universal-argument
  "C-v" 'yank-pop
  "g" 'keyboard-quit
  "d" 'hydra-kill/body
  "e" 'hydra-eval/body
  "f" 'hydra-help/body
  "x" 'hydra-buffer/body
  "SPC" 'hydra-space-commands/body)
  :custom
  (cursor-type '(bar . 1))
  (modalka-cursor-type 'box)
  :hook
  (after-init . modalka-global-mode))
#+END_SRC
** Autocompletion
*** Minibuffer completion
**** Ivy
#+BEGIN_SRC emacs-lisp
;(use-package ivy
;  :straight t
;  :config
;  (ivy-mode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :straight t
  :config
  (ivy-rich-mode t))
#+END_SRC

**** Counsel
Amx is used by Counsel-M-x

#+BEGIN_SRC emacs-lisp
(use-package amx 
  :straight t 
  :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;(use-package counsel
;  :straight t
;  :bind
;  (([remap insert-char] . counsel-unicode-char)
;   ([remap isearch-forward] . counsel-grep-or-swiper))
;  :init
;  (counsel-mode))
#+END_SRC

**** Swiper
#+BEGIN_SRC emacs-lisp
;(use-package swiper 
;  :straight t)
#+END_SRC
**** Selectrum (experimental)
#+BEGIN_SRC emacs-lisp
(use-package selectrum
  :straight t
  :config 
  (selectrum-mode t))
#+END_SRC
*** In-buffer completion
**** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :straight t
  :hook
  (after-init . global-company-mode))
#+END_SRC
**** Electric pairs
#+BEGIN_SRC emacs-lisp
(use-package elec-pair
  :config
  (electric-pair-mode t))
#+END_SRC
** Search
*** Ag
Ag is a faster grep.

#+BEGIN_SRC emacs-lisp
(use-package ag
  :straight t)
#+END_SRC
*** Prescient
/*"Simple but effective sorting and filtering for Emacs."*/

#+BEGIN_SRC emacs-lisp
(use-package prescient
  :straight t
  :config
  (prescient-persist-mode t))
#+END_SRC

Here's an interface for it to work with company.

#+BEGIN_SRC emacs-lisp
(use-package company-prescient
  :straight t
  :config
  (company-prescient-mode t))
#+END_SRC

...and with Selectrum

#+BEGIN_SRC emacs-lisp
(use-package selectrum-prescient
  :straight t
  :config
  (selectrum-prescient-mode t))
#+END_SRC
** Frame manipulation
#+BEGIN_SRC emacs-lisp
(use-package frame
  :ensure nil
  :after modalka
  :hydra (hydra-frame-movement ()
  ("o" other-frame "cycle-through-frames"))
  :general
  ;; Disable suspending
  ("C-z" . nil)
  ("C-z C-z" . nil)
  (:keymaps 'modalka-mode-map
  "r" 'hydra-frame-movement/body))
#+END_SRC
** Window manipulation
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :straight t
  :after modalka
  :hydra (hydra-windmove ()
  ("j" windmove-left "left")
  ("i" windmove-up "up")
  ("k" windmove-down "down")
  ("l" windmove-right "right")
  ("g" nil "quit"))
  :general 
  (:keymaps 'modalka-mode-map
  "w" 'hydra-windmove/body))
#+END_SRC
* Help & Manuals
** Helpful
Helpful provides better Emacs "help" buffer

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :straight t)
#+END_SRC
* Org & Documents
** Org
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil)
#+END_SRC
** PDF-tools

For viewing Pointless-Document-Format docs in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t)
#+END_SRC 
* File management
** Dired
Dired is a built-in Emacs file manager.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil)
#+END_SRC

Extra dired things

#+BEGIN_SRC emacs-lisp
(use-package dired-x
  :ensure nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :straight t
  :after dired
  :bind
  (:map dired-mode-map
        ("t" . dired-subtree-toggle)))
#+END_SRC

Image preview support for dired.

#+BEGIN_SRC emacs-lisp
(use-package image-dired
  :ensure nil)

(use-package image-dired+
  :straight t
  :after image-dired)
#+END_SRC

Hide dotfiles in dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package dired-hide-dotfiles
  :straight t
  :bind
  (:map dired-mode-map
        ("." . dired-hide-dotfiles-mode))
  :hook
  (dired-mode . dired-hide-dotfiles-mode))
#+END_SRC


Asynchronous dired

#+BEGIN_SRC emacs-lisp
(use-package async
  :straight t
  :defer t
  :init
  (dired-async-mode t))
#+END_SRC
** Set a backup directory
#+BEGIN_SRC emacs-lisp
(use-package files
  :ensure nil
  :custom
  (require-final-newline t)
  (delete-old-versions t)
  (backup-directory-alist
   `((".*" . ,(expand-file-name (concat user-emacs-directory "autosaves/")))))
  (auto-save-file-name-transforms
   `((".*" ,(expand-file-name (concat user-emacs-directory "autosaves/")) t))))
#+END_SRC
* Custom
I don't use ~M-x customize~ insterface, so, custom-file is set to /dev/null.

#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :ensure nil
  :custom
  (custom-file "/dev/null"))
#+END_SRC


