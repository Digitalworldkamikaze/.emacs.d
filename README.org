#+TITLE: Cool Emacs config.
#+AUTHOR: Scriptod
#+STARTUP: overview

* Package Management
** Package archives
Repositories of Emacs-lisp packages.

#+BEGIN_SRC emacs-lisp
(defvar gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")

(require 'package)

(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")))
#+END_SRC
** Straight
A purely functional package manager for an Emacs hacker.

#+BEGIN_SRC emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+END_SRC
** Use-package
Bootstrapping use-package - A cool macro that can both speed-up and make tidier your config. 

#+BEGIN_SRC emacs-lisp
(straight-use-package 'use-package)
#+END_SRC
** Try
Try is a tool for trying packages in Emacs without installing them permanently.

#+BEGIN_SRC emacs-lisp
(use-package try
  :straight t)
#+END_SRC

* Startup
** Start the server
If you don't use Emacs in a server mode then you definitely doing something wrong.

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC
* Libraries
** Dash
A modern list library for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package dash
  :straight t)
#+END_SRC

** Seq
Sequence-manipulation functions that complement basic functions.

#+BEGIN_SRC emacs-lisp
(use-package seq
  :ensure nil)
#+END_SRC

** Prescient
/*"Simple but effective sorting and filtering for Emacs."*/

#+BEGIN_SRC emacs-lisp
(use-package prescient
  :straight t
  :custom
  (prescient-filter-method '(literal regexp initialism))
  :config
  (prescient-persist-mode t))
#+END_SRC

Here's an interface for it to work with company.

#+BEGIN_SRC emacs-lisp
(use-package company-prescient
  :straight t
  :after company
  :config
  (company-prescient-mode t))
#+END_SRC

...and with Selectrum

#+BEGIN_SRC emacs-lisp :tangle no
(use-package selectrum-prescient
  :straight t
  :after selectrum
  :config
  (selectrum-prescient-mode t))
#+END_SRC

...and with ivy

#+BEGIN_SRC emacs-lisp
(use-package ivy-prescient
  :straight t
  :after ivy
  :config
  (ivy-prescient-mode t))
#+END_SRC
** Cl-lib
Common-lisp extensions for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package cl-lib
  :ensure nil)
#+END_SRC
* Interface & Appearence
** C source code variables
#+BEGIN_SRC emacs-lisp 
(use-package emacs
  :ensure nil
  :init
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  :custom
  (use-dialog-box nil "Dialogs via minibuffer only.")
  (tool-bar-mode nil "Disable toolbar.")
  (menu-bar-mode nil "Disable menubar.")
  (scroll-bar-mode nil "Disable scrollbar.")
  (blink-cursor-mode nil "Disable cursor blinking.")
  (scroll-step 1 "Scroll line by line.")
  (scroll-margin 4 "Top and bottom scrolling margin.")
  (inhibit-splash-screen t "Don't show the splash screen.")
  (indicate-empty-lines t "Visually indicate empty lines.")
  (indent-tabs-mode nil "Tabs are evil.")
  (tab-width 4 "Sane default for me.")
  (confirm-kill-processes nil "Don't bother confirming killing processes"))
#+END_SRC
** Simple
#+BEGIN_SRC emacs-lisp
(use-package simple
  :ensure nil
  :config
  (defalias 'yes-or-no-p 'y-or-n-p)
  :custom
  (line-number-mode t "Show line number in modeline.")
  (column-number-mode t "Show column number in modeline."))
#+END_SRC
** Themes
#+BEGIN_SRC emacs-lisp  
  (use-package doom-themes
    :straight t
    :config
    (load-theme 'doom-molokai t))
;;  (set-face-attribute 'mode-line nil
;;            :background  "#1c1e1f" ;; "#282c34"
;;           :overline nil)
;; (set-face-attribute 'mode-line-inactive nil
;;           :background "#1c1e1f" ;; "#282c34"
;;           :overline nil)
;; :custom
;; (overline-margin '5))
#+END_SRC

** Fonts & Faces
#+BEGIN_SRC emacs-lisp
(use-package faces
  :ensure nil
  :config
  (set-face-attribute 'default
                      nil
                      :family "Source Code Variable"
                      :weight 'semi-light
                      :width  'semi-condensed
                      :height 145))
#+END_SRC
** Modeline
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :straight t
  :custom
  (doom-modeline-height '35)
  :config
  (doom-modeline-mode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package diminish
  :straight t
  :config
  (diminish 'flycheck-mode)
  (diminish 'counsel-mode)
  (diminish 'ivy-mode)
  (diminish 'text-scale-mode)
  (diminish 'beacon-mode)
  (diminish 'auto-fill-function)
  (diminish 'which-key-mode)
  (diminish 'modalka-mode "normal"))
#+END_SRC
** Icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :if window-system
  :straight t
  :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :if window-system
  :straight t
  :hook
  (dired-mode . all-the-icons-dired-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-ivy
  :if window-system
  :straight t
  :after ivy
  :custom
  (all-the-icons-ivy-buffer-commands '() "Don't use for buffers.")
  :config
  (unless (file-exists-p "~/.local/share/fonts/all-the-icons.ttf")
    (all-the-icons-install-fonts t)
    (all-the-icons-ivy-setup)))
#+END_SRC
** Beacon
/* "Here your cursor is" */

#+BEGIN_SRC emacs-lisp
(use-package beacon
  :straight t
  :config
  (beacon-mode t))
#+END_SRC
** Dashboard
A cool dashboard to see every time I load muh Emacs.

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :straight t
  :config
  (dashboard-setup-startup-hook)
  ;; Set the title
  (setq dashboard-banner-logo-title "Welcome to Emacs, thermo-nuclear Man-Machine Interface for Texual data. Happy Hacking.")
  ;; Set the banner
  (setq dashboard-startup-banner 'logo)
  (setq dashboard-center-content t)
  (setq dashboard-items '((recents  . 5)
                        (bookmarks . 5))))
#+END_SRC
** Darkroom
Distraction-free mode.

#+BEGIN_SRC emacs-lisp
(use-package darkroom
  :straight t)
#+END_SRC
** Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :straight t
  :config
  (global-flycheck-mode t))
#+END_SRC
* Keyboard & Shortcuts
** General
General.el is a cool interface for making key bindings.

#+BEGIN_SRC emacs-lisp
(use-package general
  :straight t)
#+END_SRC
** Hydra
/* "Make bindings that stick around" */

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :straight t)
#+END_SRC

Hydra integration with use-package.

#+BEGIN_SRC emacs-lisp
(use-package use-package-hydra
  :straight t)
#+END_SRC
** Key-chord
#+BEGIN_SRC emacs-lisp :tangle no
(use-package key-chord
  :straight t
  :custom
  (key-chord-two-keys-delay '0.01)
  (key-chord-one-key-delay '0.15)
  :hook
  (after-init . key-chord-global-mode))

;(key-chord-define modalka-mode-map "dj" 'delete-backward-char)
;(key-chord-define modalka-mode-map "dl" 'delete-char)
;(key-chord-define modalka-mode-map "du" 'backward-kill-word)
;(key-chord-define modalka-mode-map "do" 'kill-word)
;(key-chord-define modalka-mode-map "dr" 'kill-region)
;(key-chord-define modalka-mode-map "dd" 'kill-whole-line)
;(key-chord-define modalka-mode-map "dm" 'avy-kill-whole-line)
;(key-chord-define modalka-mode-map "d;" 'kill-line)
;(key-chord-define modalka-mode-map "dh" 'reverse-kill-line)
;(key-chord-define modalka-mode-map "dt" 'zap-to-char)

;(key-chord-define modalka-mode-map "tl" 'counsel-yank-pop)


;(key-chord-define modalka-mode-map "ei" 'move-text-up)
;(key-chord-define modalka-mode-map "ek" 'move-text-down)

;(key-chord-define modalka-mode-map "qo" 'capitalize-word)
;(key-chord-define modalka-mode-map "qr" 'capitalize-region)

;(key-chord-define modalka-mode-map "xk" 'kill-buffer)
;(key-chord-define modalka-mode-map "xw" 'kill-buffer-and-window)
;(key-chord-define modalka-mode-map "xm" 'buffer-menu)
;(key-chord-define modalka-mode-map "xj" 'previous-buffer)
;(key-chord-define modalka-mode-map "xl" 'next-buffer)
;(key-chord-define modalka-mode-map "xs" 'switch-to-buffer)
;(key-chord-define modalka-mode-map "xk" 'kill-buffer)

;(key-chord-define modalka-mode-map "rr" 'set-mark-command)
;(key-chord-define modalka-mode-map "rj" 'back-button-local-forward)
;(key-chord-define modalka-mode-map "rl" 'back-button-local-backward)

#+END_SRC
** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :straight t
  :after modalka
  :general
  ('modalka-mode-map
  "m" 'avy-goto-line)
  :hydra (hydra-avy (:color blue)
  "avy"
  ("f" avy-goto-char-timer "goto-char-timer")
  ("k" avy-goto-char-2-below "goto-char-2-below")
  ("i" avy-goto-char-2-above "goto-char-2-above")
  ("l" avy-goto-char-in-line "goto-char-in-line")
  ("o" avy-goto-word-1 "goto-word-1"))
  :custom
  (avy-style 'words))
#+END_SRC
** Modal editing
Modal editing is more efficient and ergonomical way to edit text.
The package I use for implementing modal editing to my config is called Modalka.
*** Editing Hydras
**** Killing
#+BEGIN_SRC emacs-lisp
(defhydra hydra-kill (:color red)
    "kill"
    ("j" delete-backward-char "backward-char")
    ("l" delete-char "char")
    ("u" backward-kill-word "backward-word")
    ("o" kill-word "word")
    ("r" kill-region "region" :color blue)
    ("d" kill-whole-line "line")
    ("m" avy-kill-whole-line "avy-kill-whole-line")
    (";" kill-line "end-of-line")
    ("h" reverse-kill-line "to-beginnig-of-line")
    ("t" zap-to-char "to-char" :color blue)
    ("g" nil "quit"))

#+END_SRC

**** Yanking
#+BEGIN_SRC emacs-lisp
(defhydra hydra-yank ()
  "yank"
  ("y" yank nil)
  ("t" yank-pop nil)
  ("k" (yank-pop 1) "next")
  ("i" (yank-pop -1) "prev")
  ("l" counsel-yank-pop "list" :color blue)
  ("g" nil "quit"))
#+END_SRC
**** Move text
#+BEGIN_SRC emacs-lisp
(use-package move-text
  :straight t
  :hydra hydra-move-text ()
  "Move text"
  ("i" move-text-up "up")
  ("k" move-text-down "down")
  ("g" nil "quit"))
#+END_SRC
**** Capitalizing
#+BEGIN_SRC emacs-lisp
(defhydra hydra-capitalize ()
  "capitalize"
  ("o" capitalize-word "word")
  ("r" capitalize-region "region"))
#+END_SRC
**** Commenting
#+BEGIN_SRC emacs-lisp
(defhydra hydra-comment ()
  ("b" comment-box "box"))
#+END_SRC
**** Buffer navigation & manipulation
#+BEGIN_SRC emacs-lisp
(defhydra hydra-buffer (:color blue)
    ("k" kill-buffer "kill-buffer")
    ("w" kill-buffer-and-window "kill-buffer-and-window")
    ("m" buffer-menu "buffer-menu")
    ("j" previous-buffer "previous-buffer" :color red)
    ("l" next-buffer "next-buffer" :color red)
    ("s" switch-to-buffer "switch-buffer")
    ("g" nil "quit"))
#+END_SRC
**** Mark ring
#+BEGIN_SRC emacs-lisp
(use-package back-button
  :straight t
  :after modalka
  :hydra (hydra-mark-ring ()
  ("r" set-mark-command "set-mark" :color blue)
  ("j" back-button-local-forward "local-forward")
  ("l" back-button-local-backward "local-backward")
  ("g" nil "quit")))
#+END_SRC
**** Evaluation
#+BEGIN_SRC emacs-lisp
(defhydra hydra-eval (:color blue)
    "eval"
    ("d" eval-defun "defun")
    ("b" eval-buffer "buffer")
    ("r" eval-region "region")
    ("s" eval-last-sexp "last-sexp")
    ("e" eval-expression "expression")
    ("g" nil "quit"))
#+END_SRC
**** Package Management
#+BEGIN_SRC emacs-lisp
(defhydra hydra-package (:color blue)
    ("i" package-install "install")
    ("r" package-refresh-contents "refresh-contents" :color red)
    ("t" try "try")
    ("d" package-delete "delete")
    ("l" package-list-packages "list-packages")
    ("g" nil "quit"))
#+END_SRC
**** Help
#+BEGIN_SRC emacs-lisp
(defhydra hydra-help (:color blue)
    ("m" man "man")
    ("i" info "info")
    ("?" help-for-help "help-for-help")
    ("n" view-emacs-news "news")
    ("C" describe-coding-system "describe-coding-system")
    ("I" describe-input-method "describe-input-method")
    ("L" describe-language-environment "describe-language-environment")
    ("P" describe-package "describe-package")
    ("b" describe-bindings "describe-bindings")
    ("c" describe-key-briefly "describe-key-briefly")
    ("f" describe-function "describe-function")
    ("g" describe-gnu-project "describe-gnu-project")
    ("k" describe-key "describe-key")
    ("m" describe-mode "describe-mode")
    ("o" describe-symbol "describe-symbol")
    ("v" describe-variable "describe-variable")
    ("g" nil "quit"))
#+END_SRC
**** Zooming
Zooming in and out. One of the space commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-zoom ()
    "zoom"
    ("i" text-scale-increase "in")
    ("k" text-scale-decrease "out"))
#+END_SRC
**** Space-commands
Commands that you don't need right at your fingers, but ones you need pretty often. Bound to Space.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-space-commands (:color blue)
    ("s" save-buffer "save-buffer" :color red)
    ("f" find-file "find-file" :color red)
    ("Q" kill-emacs "kill-emacs")
    ("d" dired "dired")
    ("a" org-agenda "org-agenda")
    ("p" hydra-package/body "package")
    ("z" hydra-zoom/body "zoom")
    ("h" hydra-help/body "help")
    ("i" beginning-of-buffer "beginning")
    ("k" end-of-buffer "end-of-buffer")
    ("u" scroll-down "scroll-up")
    ("o" scroll-up "scroll-down")
    ("e" hydra-eval/body "eval")
    ("g" nil "quit"))
#+END_SRC
*** Modalka
#+BEGIN_SRC emacs-lisp
;; These functions will be needed soon.
(defun enable-modalka-mode ()
 (interactive)
 (modalka-mode t))

(defun reverse-kill-line ()
  (interactive)
  (kill-line 0))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package modalka
  :straight t
  :general
  ("C-;" 'enable-modalka-mode)
  ("<escape>" 'enable-modalka-mode) ; enable insert-mode
  ('modalka-mode-map
  "q" 'hydra-capitalize/body
  "w" 'copy-region-as-kill
  "e" 'hydra-move-text/body
  "r" 'hydra-mark-ring/body
  "t" 'hydra-yank/yank
  "y" 'undo
  "u" 'left-word
  "i" 'previous-line
  "o" 'right-word
  "p" 'modalka-mode ; enable insert-mode
  "a" 'execute-extended-command
  "s" 'isearch-forward
  "d" 'hydra-kill/body
  "f" 'hydra-avy/body
  "g" 'keyboard-quit
  "h" 'beginning-of-line
  "j" 'backward-char
  "k" 'next-line
  "l" 'forward-char
  ";" 'end-of-line
  "x" 'hydra-buffer/body
  "n" 'universal-argument
  "(" 'backward-sexp
  ")" 'forward-sexp
  "SPC" 'hydra-space-commands/body)
  :custom
  (cursor-type '(bar . 1))
  (modalka-cursor-type 'box)
  :hook
  (after-init . modalka-global-mode))
#+END_SRC
** Frame Manipulation
#+BEGIN_SRC emacs-lisp
(use-package frame
  :ensure nil
  :after modalka
  :hydra (hydra-frame ()
  ("o" other-frame "other-frame")
  ("3" make-frame-command "make-frame-command")
  ("2" delete-other-frames "delete-other-frames")
  ("1" delete-frame "delete-frame"))
  :general
  ;; Disable suspending
  ("C-z" . nil)
  ("C-z C-z" . nil)
  (:keymaps 'modalka-mode-map
  "c" 'hydra-frame/body))
#+END_SRC
** Window manipulation
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :straight t
  :after modalka
  :hydra (hydra-window ()
  ("z" ace-window "select-window" :color blue)
  ("3" split-window-right "split-window-right")
  ("2" delete-other-windows "delete-other-windows")
  ("1" delete-window "delete-window")
  ("g" nil "quit"))
  :general
  (:keymaps 'modalka-mode-map
  "z" 'hydra-window/body))
#+END_SRC
* Search
** Ripgrep
#+BEGIN_SRC emacs-lisp
(use-package rg
  :straight t)
#+END_SRC
** Ag
Ag is a faster grep

#+BEGIN_SRC emacs-lisp
(use-package ag
  :straight t)
#+END_SRC
* Programming
** Languages
*** Lisps
**** Smartparens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :straight t
  :hook
  (prog-mode . smartparens-mode))
#+END_SRC
** Autocompletion
*** Minibuffer completion
**** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :straight t
  :config
  (ivy-mode t)
  :general 
  ('ivy-mode-map
  "C-i" 'ivy-previous-line
  "C-k" 'ivy-next-line))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :after counsel
  :straight t
  :config
  (ivy-rich-mode t))
#+END_SRC
**** Counsel
Amx is used by ~Counsel-M-x~.

#+BEGIN_SRC emacs-lisp
(use-package amx
  :straight t 
  :defer t)
#+END_SRC

Counsel itself.

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :straight t
  :bind
  (([remap insert-char] . counsel-unicode-char)
   ([remap isearch-forward] . counsel-grep-or-swiper))
  :init
  (counsel-mode))
#+END_SRC

**** Swiper
#+BEGIN_SRC emacs-lisp
(use-package swiper 
  :straight t)
#+END_SRC
**** Selectrum
I don't use that one anymore.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package selectrum
  :straight t
  :config 
  (selectrum-mode t))
#+END_SRC
*** In-buffer completion
**** Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :straight t
  :config
  (setq company-idle-delay 0)
  (setq company-minimum-prefix-length 1)
  (setq company-selection-wrap-around t)
  (company-tng-configure-default)
  :hook
  (after-init . global-company-mode))
#+END_SRC
**** Electric pairs
#+BEGIN_SRC emacs-lisp
(use-package elec-pair
  :config
  (electric-pair-mode t))
#+END_SRC
* Help & Manuals
** Helpful
Helpful provides better Emacs "help" buffer

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :straight t)
#+END_SRC
** Which key?
A nice little tool to remind you about what keys do you want to press.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :straight t
  :config
  (which-key-mode t)
  (setq which-key-idle-delay 0.4
        which-key-idle-secondary-delay 0.4))
#+END_SRC
* Term & Shell
** Vterm
#+BEGIN_SRC emacs-lisp
(use-package vterm
  :straight t)
#+END_SRC
* Org & Documents
** Org
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil
  :hook
  (org-mode . auto-fill-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-pretty-table
  :straight (org-pretty-table :type git :host github :repo "Fuco1/org-pretty-table")
  :hook
  (org-mode . org-pretty-table-mode))
#+END_SRC
** PDF-tools

For viewing Pointless-Document-Format docs in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :straight t)
#+END_SRC 
* File management
** Dired
Dired is a built-in Emacs file manager.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil)
#+END_SRC

Extra dired things

#+BEGIN_SRC emacs-lisp
(use-package dired-x
  :ensure nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :straight t
  :after dired
  :bind
  (:map dired-mode-map
        ("t" . dired-subtree-toggle)))
#+END_SRC

Image preview support for dired.

#+BEGIN_SRC emacs-lisp
(use-package image-dired
  :ensure nil)

(use-package image-dired+
  :straight t
  :after image-dired)
#+END_SRC

Hide dotfiles in dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package dired-hide-dotfiles
  :straight t
  :bind
  (:map dired-mode-map
        ("." . dired-hide-dotfiles-mode))
  :hook
  (dired-mode . dired-hide-dotfiles-mode))
#+END_SRC


Asynchronous dired

#+BEGIN_SRC emacs-lisp
(use-package async
  :straight t
  :defer t
  :init
  (dired-async-mode t))
#+END_SRC

** Set a backup directory
#+BEGIN_SRC emacs-lisp
(use-package files
  :ensure nil
  :custom
  (require-final-newline t)
  (delete-old-versions t)
  (backup-directory-alist
   `((".*" . ,(expand-file-name (concat user-emacs-directory "autosaves/")))))
  (auto-save-file-name-transforms
   `((".*" ,(expand-file-name (concat user-emacs-directory "autosaves/")) t))))
#+END_SRC
* Custom
I don't use ~M-x customize~ insterface, so custom-file is set to /dev/null.

#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :ensure nil
  :custom
  (custom-file "/dev/null"))
#+END_SRC





