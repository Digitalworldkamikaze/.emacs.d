#+TITLE: Cool Emacs config.
#+AUTHOR: Scriptod
#+STARTUP: overview

* Package Management
** Package archives
Repositories of Emacs-lisp packages.

#+BEGIN_SRC emacs-lisp
(defvar gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")

(require 'package)

(setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("org" . "https://orgmode.org/elpa/")))
#+END_SRC
** Use-package
Bootstrapping use-package - A cool macro that can both speed-up and make tidier your config. 

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package)
  (setq use-package-always-ensure t))
#+END_SRC
** Quelpa
For installing packages from sources.

#+BEGIN_SRC emacs-lisp
(use-package quelpa
  :ensure t)
#+END_SRC
** Try
Try is a tool for trying packages in Emacs without installing them permanently.

#+BEGIN_SRC emacs-lisp
(use-package try
  :ensure t)
#+END_SRC

* Startup
** Start the server
If you don't use Emacs in a server mode then you definitely doing something wrong.

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC
* Interface & Appearence
** Emacs variables defined in C source code
#+BEGIN_SRC emacs-lisp 
(use-package emacs
  :ensure nil
  :init
  (put 'narrow-to-page 'disabled nil)
  (put 'narrow-to-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  :custom
  (use-dialog-box nil "Dialogs via minibuffer only.")
  (tool-bar-mode nil "Disable toolbar.")
  (menu-bar-mode nil "Disable menubar.")
  (scroll-bar-mode nil "Disable scrollbar.")
  (blink-cursor-mode nil "Disable cursor blinking.")
  (scroll-step 1 "Scroll line by line.")
  (scroll-margin 4 "Top and bottom scrolling margin.")
  (inhibit-splash-screen t "Don't show the splash screen.")
  (indicate-empty-lines t "Visually indicate empty lines.")
  (indent-tabs-mode nil "Tabs are evil.")
  (tab-width 4 "Sane default for me."))
#+END_SRC
** Simple
#+BEGIN_SRC emacs-lisp
(use-package simple
  :ensure nil
  :config
  (defalias 'yes-or-no-p 'y-or-n-p)
  :custom
  (line-number-mode t "Show line number in modeline.")
  (column-number-mode t "Show column number in modeline."))
#+END_SRC
** Themes
#+BEGIN_SRC emacs-lisp
;(use-package doom-themes
;  :ensure t
;  :config
;  (load-theme 'doom-wilmersdorf t)
;  (set-face-attribute 'mode-line nil
;            :background "#282b33")
;  (set-face-attribute 'mode-line-inactive nil
;            :background "#282b33"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package doom-themes
 :ensure t
 :config
 (load-theme 'doom-Iosvkem t))
#+END_SRC
** Modeline
Mood-line is the most minimalistic modeline for Emacs I've ever seen.

#+BEGIN_SRC emacs-lisp
(use-package mood-line
  :ensure t
  :config
  (mood-line-mode)
  (set-face-attribute 'mode-line nil
            :background "#1b1d1e"
            :overline t)
  (set-face-attribute 'mode-line-inactive nil
            :background "#1b1d1e")
  :custom (overline-margin '15)
  :custom (underline-margin '10))
#+END_SRC
** Icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :if window-system
  :ensure t
  :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :if window-system
  :ensure t
  :hook
  (dired-mode . all-the-icons-dired-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-ivy
  :if window-system
  :ensure t
  :after ivy
  :custom
  (all-the-icons-ivy-buffer-commands '() "Don't use for buffers.")
  :config
  (unless (file-exists-p "~/.local/share/fonts/all-the-icons.ttf")
    (all-the-icons-install-fonts t))
  (all-the-icons-ivy-setup))
#+END_SRC
** Dashboard
A cool dashboard to see every time I load muh Emacs.

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :ensure t
  :config
  (dashboard-setup-startup-hook)
  ;; Set the title
  (setq dashboard-banner-logo-title "Happy Hacking.")
  ;; Set the banner
  (setq dashboard-startup-banner 'logo))
#+END_SRC
* Keyboard & Shortcuts
** Which key?
A nice little tool to remind you about what keys do you want to press.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config
  (which-key-mode t))
#+END_SRC
** General
General.el is a cool interface for making key bindings.

#+BEGIN_SRC emacs-lisp
(use-package general
  :ensure t)
#+END_SRC
** Hydra
"Make bindings that stick around"

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t)
#+END_SRC

Hydra integration with use-package.

#+BEGIN_SRC emacs-lisp
(use-package use-package-hydra
  :ensure t)
#+END_SRC
** Modal editing
Modal editing is more efficient and ergonomical way to edit text. The package I use for implementing modal editing to my config is called Modalka.

#+BEGIN_SRC emacs-lisp
;; These functions will be needed soon.
(defun enable-modalka-mode ()
 (interactive)
 (modalka-mode t))

(defun reverse-kill-line ()
  (interactive)
  (kill-line 0))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package modalka
  :ensure t
  :after hydra use-package-hydra
  :bind
  ("<escape>" . enable-modalka-mode)
  (:map modalka-mode-map)
  ("p" . modalka-mode)
  ("j" . backward-char)
  ("u" . left-word)
  ("C-u" . scroll-up)
  ("k" . next-line)
  ("C-k" . end-of-buffer)
  ("i" . previous-line)
  ("C-i" . beginning-of-buffer)
  ("l" . forward-char)
  ("o" . right-word)
  ("C-o" . scroll-down)
  ("h" . beginning-of-line)
  (";" . end-of-line)
  ("y" . undo)
  ("v" . set-mark-command)
  ("c" . copy-region-as-kill)
  ("a" . org-agenda)
  ("s" . isearch-forward)
  ("n" . universal-argument)
  ("C-v" . yank-pop)
  ("x" . execute-extended-command)
  :config
  :hydra (hydra-kill (modalka-mode-map "d")
    ("j" delete-backward-char "backward-char")
    ("l" delete-char "char")
    ("u" backward-kill-word "backward-word")
    ("o" kill-word "word")
    ("v" kill-region "region")
    ("d" kill-whole-line "line")
    (";" kill-line "end-of-line")
    ("h" reverse-kill-line "beginnig-of-line")
    ("g" nil "quit"))
  :hydra (hydra-package (modalka-mode-map "P")
    ("t" try "try" :color blue)
    ("i" package-install "install" :color blue)
    ("d" package-delete "delete" :color blue)
    ("r" package-refresh-contents "refresh")
    ("l" package-list-packages "list" :color blue)
    ("g" nil "quit"))
  :hydra (hydra-eval (modalka-mode-map "e")
    ("d" eval-defun "defun" :color blue)
    ("b" eval-buffer "buffer" :color blue)
    ("r" eval-region "region" :color blue)
    ("s" eval-last-sexp "sexp" :color blue)
    ("e" eval-expression "expression" :color blue)
    ("g" nil "quit"))
  :hydra (hydra-help (modalka-mode-map "?")
    ("m" man "man" :color blue)
    ("n" view-emacs-news "news" :color blue)
    ("d k" describe-key "describe-key" :color blue)
    ("d f" describe-function "describe-function" :color blue)
    ("d v" describe-variable "describe-variable" :color blue)
    ("g" nil "quit"))
  :hydra (hydra-files (modalka-mode-map "f")
    ("d" dired "open-directory" :color blue)
    ("g" nil "quit"))
  :hydra (hydra-buffer (modalka-mode-map "b")
    ("k" kill-buffer "kill-buffer" :color blue)
    ("K" kill-buffer-and-window "kill-buffer-and-window" :color blue)
    ("m" buffer-menu "buffer-menu" :color blue)
    ("j" previous-buffer "previous-buffer")
    ("l" next-buffer "next-buffer")
    ("g" nil "quit"))
  :hydra (hydra-space-commands (modalka-mode-map "SPC")
    ("s" save-buffer "save-buffer")
    ("f" find-file "find-file")
    ("Q" kill-emacs "kill-emacs" :color blue)
    ("g" nil "quit"))
  :hydra (hydra-zoom (modalka-mode-map "z")
    "zoom"
    ("i" text-scale-increase "in")
    ("k" text-scale-decrease "out"))
  :custom
  (cursor-type '(bar . 1))
  (modalka-cursor-type 'box)
  :hook
  (after-init . modalka-global-mode))
#+END_SRC
** Autocompletion
*** Minibuffer completion
**** Ivy
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :config
  (ivy-mode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy-rich
  :ensure t
  :config
  (ivy-rich-mode t))
#+END_SRC

**** Counsel
Amx is used by Counsel-M-x

#+BEGIN_SRC emacs-lisp
(use-package amx 
  :ensure t 
  :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  :bind
  (([remap insert-char] . counsel-unicode-char)
   ([remap isearch-forward] . counsel-grep-or-swiper))
  :init
  (counsel-mode))
#+END_SRC

**** Swiper
#+BEGIN_SRC emacs-lisp
(use-package swiper 
  :ensure t)
#+END_SRC
*** In-buffer completion
**** Company 

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (company-mode t))
#+END_SRC
*** Expansion
** Search
*** Ag
Ag is a faster grep.

#+BEGIN_SRC emacs-lisp
(use-package ag
  :ensure t)
#+END_SRC
*** Isearch
#+BEGIN_SRC emacs-lisp
(use-package isearch
  :ensure nil
  :bind
  ("M-f" . 'isearch-forward)
  ("C-f" . 'isearch-backward))
#+END_SRC
** Frame manipulation
#+BEGIN_SRC emacs-lisp
(use-package frame
  :ensure nil
  :bind
  ("C-z" . nil)
  ("C-z C-z" . nil)
  (:map modalka-mode-map)
  ("o" . 'other-frame))
#+END_SRC
* Help & Manuals
** Helpful
Helpful provides better Emacs "help" buffer

#+BEGIN_SRC emacs-lisp
(use-package helpful
  :ensure t)
#+END_SRC
* Org & Documents
** Org
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil)
#+END_SRC
** PDF-tools

For viewing Pointless-Document-Format docs in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t)
#+END_SRC 
* File management
** Dired
Dired is a built-in Emacs file manager.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil)
#+END_SRC

Extra dired things

#+BEGIN_SRC emacs-lisp
(use-package dired-x
  :ensure nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
  :ensure t
  :after dired
  :bind
  (:map dired-mode-map
        ("t" . dired-subtree-toggle)))
#+END_SRC

Image preview support for dired.

#+BEGIN_SRC emacs-lisp
(use-package image-dired
  :ensure nil)

(use-package image-dired+
  :ensure t
  :after image-dired)
#+END_SRC

Hide dotfiles in dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package dired-hide-dotfiles
  :ensure t
  :bind
  (:map dired-mode-map
        ("." . dired-hide-dotfiles-mode))
  :hook
  (dired-mode . dired-hide-dotfiles-mode))
#+END_SRC
** Set a backup directory
#+BEGIN_SRC emacs-lisp
(use-package files
  :ensure nil
  :custom
  (require-final-newline t)
  (delete-old-versions t)
  (backup-directory-alist
   `((".*" . ,(expand-file-name (concat user-emacs-directory "autosaves/")))))
  (auto-save-file-name-transforms
   `((".*" ,(expand-file-name (concat user-emacs-directory "autosaves/")) t))))
#+END_SRC

Asynchronous dired

#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :defer t
  :init
  (dired-async-mode t))
#+END_SRC
* Custom
I don't use ~M-x customize~ insterface, so, custom-file is set to /dev/null.

#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :ensure nil
  :custom
  (custom-file "/dev/null"))
#+END_SRC


